#!/usr/bin/env node
"use strict";

var _commander = _interopRequireDefault(require("commander"));

var _chalk = _interopRequireDefault(require("chalk"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _puppeteer = _interopRequireDefault(require("puppeteer"));

var _package = _interopRequireDefault(require("./package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

process.title = "mmdc";

const error = message => {
  console.log(_chalk.default.red(`\n${message}\n`));
  process.exit(1);
};

const warn = message => {
  console.log(_chalk.default.yellow(`\n${message}\n`));
};

const checkConfigFile = file => {
  if (!_fs.default.existsSync(file)) {
    error(`Configuration file "${file}" doesn't exist`);
  }
};

const inputPipedFromStdin = () => _fs.default.fstatSync(0).isFIFO();

const getInputData = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (inputFile) {
    return new Promise((resolve, reject) => {
      // if an input file has been specified using '-i', it takes precedence over
      // piping from stdin
      if (typeof inputFile !== 'undefined') {
        return _fs.default.readFile(inputFile, 'utf-8', (err, data) => {
          if (err) {
            return reject(err);
          }

          return resolve(data);
        });
      }

      let data = '';
      process.stdin.on('readable', function () {
        var chunk = this.read();

        if (chunk !== null) {
          data += chunk;
        }
      });
      process.stdin.on('error', function (err) {
        reject(err);
      });
      process.stdin.on('end', function () {
        resolve(data);
      });
    });
  });

  return function getInputData(_x) {
    return _ref.apply(this, arguments);
  };
}();

const convertToValidXML = html => {
  // <br> tags in valid HTML (from innerHTML) look like <br>, but they must look like <br/> to be valid XML (such as SVG)
  return html.replace(/<br>/gi, '<br/>');
};

_commander.default.version(_package.default.version).option('-t, --theme [theme]', 'Theme of the chart, could be default, forest, dark or neutral. Optional. Default: default', /^default|forest|dark|neutral$/, 'default').option('-w, --width [width]', 'Width of the page. Optional. Default: 800', /^\d+$/, '800').option('-H, --height [height]', 'Height of the page. Optional. Default: 600', /^\d+$/, '600').option('-i, --input <input>', 'Input mermaid file. Files ending in .md will be treated as Markdown and all charts (e.g. ```mermaid (...)```) will be extracted and generated. Required.').option('-o, --output [output]', 'Output file. It should be either md, svg, png or pdf. Optional. Default: input + ".svg"').option('-b, --backgroundColor [backgroundColor]', 'Background color. Example: transparent, red, \'#F0F0F0\'. Optional. Default: white').option('-c, --configFile [configFile]', 'JSON configuration file for mermaid. Optional').option('-C, --cssFile [cssFile]', 'CSS file for the page. Optional').option('-s, --scale [scale]', 'Puppeteer scale factor, default 1. Optional').option('-f, --pdfFit [pdfFit]', 'Scale PDF to fit chart').option('-q, --quiet', 'Suppress log output').option('-p --puppeteerConfigFile [puppeteerConfigFile]', 'JSON configuration file for puppeteer. Optional').parse(process.argv);

const options = _commander.default.opts();

let {
  theme,
  width,
  height,
  input,
  output,
  backgroundColor,
  configFile,
  cssFile,
  puppeteerConfigFile,
  scale,
  pdfFit,
  quiet
} = options; // check input file

if (!(input || inputPipedFromStdin())) {
  console.log(_chalk.default.red(`\nPlease specify input file: -i <input>\n`));

  _commander.default.help();

  process.exit(1);
}

if (input && !_fs.default.existsSync(input)) {
  error(`Input file "${input}" doesn't exist`);
} // check output file


if (!output) {
  // if an input file is defined, it should take precedence, otherwise, input is
  // coming from stdin and just name the file out.svg, if it hasn't been
  // specified with the '-o' option
  output = input ? input + '.svg' : 'out.svg';
}

if (!/\.(?:svg|png|pdf|md)$/.test(output)) {
  error(`Output file must end with ".md", ".svg", ".png" or ".pdf"`);
}

const outputDir = _path.default.dirname(output);

if (!_fs.default.existsSync(outputDir)) {
  error(`Output directory "${outputDir}/" doesn't exist`);
} // check config files


let mermaidConfig = {
  theme
};

if (configFile) {
  checkConfigFile(configFile);
  mermaidConfig = Object.assign(mermaidConfig, JSON.parse(_fs.default.readFileSync(configFile, 'utf-8')));
}

let puppeteerConfig = {};

if (puppeteerConfigFile) {
  checkConfigFile(puppeteerConfigFile);
  puppeteerConfig = JSON.parse(_fs.default.readFileSync(puppeteerConfigFile, 'utf-8'));
} // check cssFile


let myCSS;

if (cssFile) {
  if (!_fs.default.existsSync(cssFile)) {
    error(`CSS file "${cssFile}" doesn't exist`);
  }

  myCSS = _fs.default.readFileSync(cssFile, 'utf-8');
}

const info = message => {
  if (!quiet) {
    console.info(message);
  }
}; // normalize args


width = parseInt(width);
height = parseInt(height);
backgroundColor = backgroundColor || 'white';
const deviceScaleFactor = parseInt(scale || 1, 10);

const parseMMD = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (browser, definition, output) {
    const page = yield browser.newPage();
    page.setViewport({
      width,
      height,
      deviceScaleFactor
    });
    yield page.goto(`file://${_path.default.join(__dirname, 'index.html')}`);
    yield page.evaluate(`document.body.style.background = '${backgroundColor}'`);
    const result = yield page.$eval('#container', (container, definition, mermaidConfig, myCSS) => {
      container.textContent = definition;
      window.mermaid.initialize(mermaidConfig);

      if (myCSS) {
        const head = window.document.head || window.document.getElementsByTagName('head')[0];
        const style = document.createElement('style');
        style.type = 'text/css';

        if (style.styleSheet) {
          style.styleSheet.cssText = myCSS;
        } else {
          style.appendChild(document.createTextNode(myCSS));
        }

        head.appendChild(style);
      }

      try {
        window.mermaid.init(undefined, container);
        return {
          status: 'success'
        };
      } catch (error) {
        return {
          status: 'error',
          error,
          message: error.message
        };
      }
    }, definition, mermaidConfig, myCSS);

    if (result.status === 'error') {
      error(result.message);
    }

    if (output.endsWith('svg')) {
      const svg = yield page.$eval('#container', (container, backgroundColor) => {
        var _container$getElement, _container$getElement2;

        const svg = (_container$getElement = container.getElementsByTagName) === null || _container$getElement === void 0 ? void 0 : (_container$getElement2 = _container$getElement.call(container, 'svg')) === null || _container$getElement2 === void 0 ? void 0 : _container$getElement2[0];

        if (svg.style) {
          svg.style.backgroundColor = backgroundColor;
        } else {
          warn("svg not found. Not applying background color.");
        }

        return container.innerHTML;
      }, backgroundColor);
      const svg_xml = convertToValidXML(svg);

      _fs.default.writeFileSync(output, svg_xml);
    } else if (output.endsWith('png')) {
      const clip = yield page.$eval('svg', svg => {
        const react = svg.getBoundingClientRect();
        return {
          x: Math.floor(react.left),
          y: Math.floor(react.top),
          width: Math.ceil(react.width),
          height: Math.ceil(react.height)
        };
      });
      yield page.setViewport({
        width: clip.x + clip.width,
        height: clip.y + clip.height,
        deviceScaleFactor
      });
      yield page.screenshot({
        path: output,
        clip,
        omitBackground: backgroundColor === 'transparent'
      });
    } else {
      // pdf
      if (pdfFit) {
        const clip = yield page.$eval('svg', svg => {
          const react = svg.getBoundingClientRect();
          return {
            x: react.left,
            y: react.top,
            width: react.width,
            height: react.height
          };
        });
        yield page.pdf({
          path: output,
          printBackground: backgroundColor !== 'transparent',
          width: Math.ceil(clip.width) + clip.x * 2 + 'px',
          height: Math.ceil(clip.height) + clip.y * 2 + 'px',
          pageRanges: '1-1'
        });
      } else {
        yield page.pdf({
          path: output,
          printBackground: backgroundColor !== 'transparent'
        });
      }
    }
  });

  return function parseMMD(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

_asyncToGenerator(function* () {
  const mermaidChartsInMarkdown = '^```(?:mermaid)(\r?\n([\\s\\S]*?))```$';
  const mermaidChartsInMarkdownRegexGlobal = new RegExp(mermaidChartsInMarkdown, 'gm');
  const mermaidChartsInMarkdownRegex = new RegExp(mermaidChartsInMarkdown);
  const browser = yield _puppeteer.default.launch(puppeteerConfig);
  const definition = yield getInputData(input);

  if (/\.md$/.test(input)) {
    const diagrams = [];
    const outDefinition = definition.replace(mermaidChartsInMarkdownRegexGlobal, mermaidMd => {
      const md = mermaidChartsInMarkdownRegex.exec(mermaidMd)[1]; // Output can be either a template image file, or a `.md` output file.
      //   If it is a template image file, use that to created numbered diagrams
      //     I.e. if "out.png", use "out-1.png", "out-2.png", etc
      //   If it is an output `.md` file, use that to base .svg numbered diagrams on
      //     I.e. if "out.md". use "out-1.svg", "out-2.svg", etc

      const outputFile = output.replace(/(\..*)$/, `-${diagrams.length + 1}$1`).replace(/(\.md)$/, '.svg');
      const outputFileRelative = `./${_path.default.relative(_path.default.dirname(_path.default.resolve(output)), _path.default.resolve(outputFile))}`;
      diagrams.push([outputFile, md]);
      return `![diagram](${outputFileRelative})`;
    });

    if (diagrams.length) {
      info(`Found ${diagrams.length} mermaid charts in Markdown input`);
      yield Promise.all(diagrams.map( /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator(function* ([imgFile, md]) {
          yield parseMMD(browser, md, imgFile);
          info(` ✅ ${imgFile}`);
        });

        return function (_x5) {
          return _ref4.apply(this, arguments);
        };
      }()));
    } else {
      info(`No mermaid charts found in Markdown input`);
    }

    if (/\.md$/.test(output)) {
      yield _fs.default.promises.writeFile(output, outDefinition, 'utf-8');
      info(` ✅ ${output}`);
    }
  } else {
    info(`Generating single mermaid chart`);
    yield parseMMD(browser, definition, output);
  }

  yield browser.close();
})();
